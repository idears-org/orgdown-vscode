* 005. A Multi-Layered, Fixture-Driven Testing Architecture

- Status: Accepted & Implemented
- Date: 2025-08-06
- Deciders: san, Gemini

** 1. Context and Problem Statement

The initial approach to testing our TextMate grammar relied on manual processes and monolithic snapshot tests. This presented several critical challenges:

- **Lack of Granularity**: It was impossible to test a single piece of syntax logic (e.g., one regular expression) in isolation. Any small change required a full, slow, and often noisy snapshot regeneration.
- **Implicit Connections**: The relationship between a regular expression, its capture groups, and the TextMate scopes they mapped to was implicit and not explicitly tested, making the grammar brittle and hard to refactor.
- **Poor Developer Experience**: Writing tests was not intuitive. The feedback loop was slow, and it was difficult to document the intent of a specific test case.

We needed a professional-grade testing architecture that provided a fast feedback loop, high confidence in changes, and a clear, self-documenting way to write and manage tests.

** 2. The Core Principles (The "Why")

To solve these problems, we established two foundational principles that govern our entire testing philosophy.

*** 2.1. The Single Source of Truth (SSoT)

We enforce a strict separation of concerns by ensuring every piece of our grammar engine is defined in exactly one place.

- **The Logic (`common/src/grammar/regex.ts`)**: This file is the SSoT for *what* we capture. It contains all named regular expressions. Its sole responsibility is to extract substrings from text.
- **The Scopes (`common/src/scoping.ts`)**: This file is the SSoT for *what* our captured data is named. It contains all named TextMate scopes.
- **The Structure (`syntaxes/org.tmLanguage.template.yaml`)**: This file is the SSoT for *how* we map Logic and Scopes together.
- **The Test Cases (`test/fixtures/`)**: These files are the SSoT for *what* we test. They contain the input text and the expected outcomes for all test types.

This separation means we can modify one aspect (e.g., a regex pattern) without breaking the others, and it allows us to test each component independently.

*** 2.2. Multi-Layered Testing

No single testing method can provide both speed and high-fidelity validation. Therefore, we use a three-layered approach, where each layer serves a distinct and vital purpose:

- **L1: Unit Testing (The Fast Loop)**: Its purpose is **speed** and **logic validation**. It tests the SSoT for Logic (`regex.ts`) against the SSoT for Test Cases (`fixtures/*.org`). It answers the question: "Does my regex capture the correct data?" This provides sub-second feedback during development.

- **L2: Manual Verification (The Sanity Check)**: Its purpose is **visual confirmation**. By compiling fixtures into clean `.inspection.org` files, developers can use VS Code's built-in scope inspector to visually confirm that the final highlighting matches the documented intent in the fixture's `:PROPERTIES:` drawer. It answers: "Does the final result *look* right?"

- **L3: Snapshot Testing (The Safety Net)**: Its purpose is **preventing regressions** in the final, integrated product. It takes the result of the fully compiled grammar applied to the inspection files and compares it to a previously approved snapshot. It answers: "Is the final result *exactly* the same as the last time it was approved?" This is the ultimate guarantee of stability.

Crucially, we decided that **scope testing belongs at L3, not L1**. Forcing L1 unit tests to parse the YAML grammar file would violate the SSoT principle, slow down the fast loop, and make test failures ambiguous. L3 snapshot testing is the correct and most precise tool for validating the final, integrated scope mappings.

#+begin_src mermaid

flowchart TD
    subgraph Fixtures & Inputs
        F1[test/fixtures/*.org]
        G1[syntaxes/org.tmLanguage.template.yaml]
        R1[common/src/grammar/regex.ts]
        S1[common/src/scoping.ts]
    end

    subgraph Build Scripts
        BG[scripts/build-grammar.ts]
        BI[scripts/build-inspections.ts]
        BT[scripts/build-theme.ts]
    end

    subgraph Outputs
        CG[syntaxes/org.configuration.json]
        INSP[test/inspection/*.org]
        DT["themes/orgdown-debug-theme.json (Debug Only)"]
    end

    subgraph Testing
        VITEST[vitest L1 Unit]
        VSCOPE[VS Code Scope Inspector L2 Manual]
        SNAP[L3 Snapshot Test]
    end

    %% Fixture flow
    F1 --> BG
    F1 --> BI
    F1 --> VITEST

    %% Grammar/Regex/Scope flow
    R1 --> BG
    R1 --> VITEST
    S1 --> BG
    S1 --> BT

    %% Grammar template flow
    G1 --> BG

    %% Build outputs
    BG --> CG
    BI --> INSP
    BT --> DT

    %% L1 Unit
    VITEST -.->|verify regex.ts| F1

    %% L2 Manual
    CG --> VSCOPE
    INSP --> VSCOPE
    DT --> VSCOPE

    %% L3 Snapshot
    CG --> SNAP
    INSP --> SNAP

    classDef input fill:#e0f7fa,stroke:#333,stroke-width:1px;
    classDef output fill:#fff9c4,stroke:#333,stroke-width:1px;
    classDef test fill:#ffe0b2,stroke:#333,stroke-width:1px;
    class F1,G1,R1,S1 input;
    class CG,INSP,DT output;
    class VITEST,VSCOPE,SNAP test;

#+end_src

** 3. The Decision Outcome: A Native Org Mode Fixture Format

Based on these principles, we designed a highly-structured and self-documenting fixture format that leverages native Org Mode constructs like headlines for test cases, source blocks for input, and results blocks for expectations.

This format is the cornerstone of our entire workflow. The complete and authoritative guide to its syntax, conventions, and advanced features is maintained in the single source of truth for fixtures: [[../test/fixture-howto.org][The Fixture How-To Guide]].

** 4. Consequences

- **Positive**:
  - **High Confidence**: Changes are verified at the logic, visual, and integration levels.
  - **Superior Maintainability**: Logic, structure, and tests are decoupled and easy to reason about.
  - **Excellent Developer Experience**: Writing and organizing tests in Org Mode is natural and efficient. The fast TDD loop dramatically speeds up development.
  - **Self-Documenting**: The fixture files themselves become rich, living documentation of the grammar's behavior.
- **Negative**:
  - **Increased Complexity**: The architecture has more moving parts than a simple, monolithic test.
  - **Learning Curve**: Contributors must familiarize themselves with the workflow, which is why the Development Guide is essential.
