* 005. A Multi-Layered, Fixture-Driven Testing Architecture

- Status: Accepted & Implemented
- Date: 2025-08-06
- Deciders: san, Gemini

** 1. Context and Problem Statement

The initial approach to testing our TextMate grammar relied on manual processes and monolithic snapshot tests. This presented several critical challenges:

- **Lack of Granularity**: It was impossible to test a single piece of syntax logic (e.g., one regular expression) in isolation. Any small change required a full, slow, and often noisy snapshot regeneration.
- **Implicit Connections**: The relationship between a regular expression, its capture groups, and the TextMate scopes they mapped to was implicit and not explicitly tested, making the grammar brittle and hard to refactor.
- **Poor Developer Experience**: Writing tests was not intuitive. The feedback loop was slow, and it was difficult to document the intent of a specific test case.

We needed a professional-grade testing architecture that provided a fast feedback loop, high confidence in changes, and a clear, self-documenting way to write and manage tests.

** 2. The Core Principles (The "Why")

To solve these problems, we established two foundational principles that govern our entire testing philosophy.

*** 2.1. The Single Source of Truth (SSoT)

We enforce a strict separation of concerns by ensuring every piece of our grammar engine is defined in exactly one place.

- **The Logic (`common/src/grammar/regex.ts`)**: This file is the SSoT for *what* we capture. It contains all named regular expressions. Its sole responsibility is to extract substrings from text.
- **The Structure (`syntaxes/org.tmLanguage.template.yaml`)**: This file is the SSoT for *how* we name the captured data. Its sole responsibility is to map capture groups from the regexes to semantic TextMate scope names.
- **The Test Cases (`test/fixtures/`)**: These files are the SSoT for *what* we test. They contain the input text and the expected outcomes for all test types.

This separation means we can modify one aspect (e.g., a regex pattern) without breaking the others, and it allows us to test each component independently.

*** 2.2. Multi-Layered Testing

No single testing method can provide both speed and high-fidelity validation. Therefore, we use a three-layered approach, where each layer serves a distinct and vital purpose:

- **L1: Unit Testing (The Fast Loop)**: Its purpose is **speed** and **logic validation**. It tests the SSoT for Logic (`regex.ts`) against the SSoT for Test Cases (`fixtures/*.org`). It answers the question: "Does my regex capture the correct data?" This provides sub-second feedback during development.

- **L2: Manual Verification (The Sanity Check)**: Its purpose is **visual confirmation**. By compiling fixtures into clean `.inspection.org` files, developers can use VS Code's built-in scope inspector to visually confirm that the final highlighting matches the documented intent in the fixture's `:PROPERTIES:` drawer. It answers: "Does the final result *look* right?"

- **L3: Snapshot Testing (The Safety Net)**: Its purpose is **preventing regressions** in the final, integrated product. It takes the result of the fully compiled grammar applied to the inspection files and compares it to a previously approved snapshot. It answers: "Is the final result *exactly* the same as the last time it was approved?" This is the ultimate guarantee of stability.

Crucially, we decided that **scope testing belongs at L3, not L1**. Forcing L1 unit tests to parse the YAML grammar file would violate the SSoT principle, slow down the fast loop, and make test failures ambiguous. L3 snapshot testing is the correct and most precise tool for validating the final, integrated scope mappings.

#+begin_src mermaid

flowchart TD
    subgraph Fixtures & Inputs
        F1[test/fixtures/*.org]
        G1[syntaxes/org.tmLanguage.template.yaml]
        R1[common/src/grammar/regex.ts]
    end

    subgraph Build Scripts
        BG[scripts/build-grammar.ts]
        BI[scripts/build-inspections.ts]
    end

    subgraph Outputs
        CG[syntaxes/org.configuration.json]
        INSP[test/inspection/*.org]
    end

    subgraph Testing
        VITEST[vitest L1 Unit]
        VSCOPE[VS Code Scope Inspector L2 Manual]
        SNAP[L3 Snapshot Test]
    end

    %% Fixture flow
    F1 --> BG
    F1 --> BI
    F1 --> VITEST

    %% Grammar/Regex flow
    R1 --> BG
    R1 --> VITEST

    %% Grammar template flow
    G1 --> BG

    %% Build outputs
    BG --> CG
    BI --> INSP

    %% L1 Unit
    VITEST -.->|verify regex.ts| F1

    %% L2 Manual
    CG --> VSCOPE
    INSP --> VSCOPE

    %% L3 Snapshot
    CG --> SNAP
    INSP --> SNAP

    classDef input fill:#e0f7fa,stroke:#333,stroke-width:1px;
    classDef output fill:#fff9c4,stroke:#333,stroke-width:1px;
    classDef test fill:#ffe0b2,stroke:#333,stroke-width:1px;
    class F1,G1,R1 input;
    class CG,INSP output;
    class VITEST,VSCOPE,SNAP test;

#+end_src

** 3. The Decision Outcome: The V7 Fixture Format

Based on these principles, we designed a highly-structured, extensible, and self-documenting fixture format using native Org Mode features. This format is the cornerstone of our entire workflow.

- **Atomic Unit**: Each test case is an atomic unit, defined by a top-level headline (`* Test Case: ...`). This provides unambiguous grouping of all related information.
- **Structured Metadata**: A `:PROPERTIES:` drawer holds all test configuration:
  - `:SYNTAX:`: Declares the syntax rule(s) being tested (e.g., `headline`, `planning-line`).
  - `<SYNTAX_NAME>_REGEX`: Namespaced property to define the regex to use for a specific syntax.
  - `<SYNTAX_NAME>_SCOPE_*`: Namespaced properties to document the expected scopes for manual L2 verification.
- **Extensible Results**: A unified `#+RESULTS: <type> [<syntax_name>]` block structure allows for multiple types of test results within a single test case, ensuring the framework is future-proof.

This format is defined in full detail in the [[../development-guide.org][Development Guide]].

** 4. Consequences

- **Positive**:
  - **High Confidence**: Changes are verified at the logic, visual, and integration levels.
  - **Superior Maintainability**: Logic, structure, and tests are decoupled and easy to reason about.
  - **Excellent Developer Experience**: Writing and organizing tests in Org Mode is natural and efficient. The fast TDD loop dramatically speeds up development.
  - **Self-Documenting**: The fixture files themselves become rich, living documentation of the grammar's behavior.
- **Negative**:
  - **Increased Complexity**: The architecture has more moving parts than a simple, monolithic test.
  - **Learning Curve**: Contributors must familiarize themselves with the workflow, which is why the Development Guide is essential.
