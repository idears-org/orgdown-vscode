* Orgdown VS Code Extension Development Guide

Welcome, contributor! This guide provides practical instructions for contributing to Orgdown. It is designed to help you add, test, and debug new features using our automated, multi-layered testing workflow.

** 1. Core Philosophy

Our development process is built on two foundational principles:

- **Test-Driven Development (TDD)**: We write tests first. This ensures every feature is verifiable and prevents regressions.
- **Single Source of Truth (SSoT)**: Each piece of logic or data (regular expressions, grammar structure, test cases) is defined in exactly one place, eliminating duplication and inconsistency.

For a deep dive into the architectural decisions behind this workflow, please see [[../architecture_decisions/005-unified-grammar-and-test-workflow.org][ADR-005: Unified, Multi-Layered Grammar and Testing Workflow]].

** 2. Quick Start: Fixing a Highlighting Bug

This is the most common contribution. Hereâ€™s your fast track:

1.  **Find the Fixture**: Go to `test/fixtures/`. Find the `.org` file corresponding to the buggy feature (e.g., `F01-headlines.org`).
2.  **Create a Failing Test**: Add a new `* Test Case:` headline that reproduces the bug. Add the incorrect input in a `#+BEGIN_SRC` block.
3.  **Run the Test**: Run `pnpm test:unit`. Watch it fail. This is expected!
4.  **Fix the Regex**: Go to `common/src/grammar/regex.ts`. Find the relevant regular expression and fix it.
5.  **Verify the Fix**: Re-run `pnpm test:unit`. It should now pass.
6.  **Update Snapshots**: Run `pnpm test:integration`. It will likely fail because the visual output has changed. Review the changes in the `.snap` file and, if they are correct, run `pnpm test:integration -u` to update the snapshot.
7.  **Commit**: Commit your changes to the fixture file, `regex.ts`, and the updated snapshot file.

** 3. The Full Workflow: Adding a New Feature

Let's walk through the process of adding a new feature, for example, syntax highlighting for Org Mode's **Planning Lines** (e.g., `SCHEDULED: <...>`).

*** Step 0: Design the TextMate Scopes

Before writing code, design a clear TextMate scope naming scheme. This ensures our highlighting is semantic and compatible with themes. (See *Section 4.1* for principles).

For our Planning Line feature, the design might be:
- `meta.planning.org`
  - `keyword.other.planning.org`
  - `meta.timestamp.org`
    - `constant.numeric.date.org`

*** Step 1: Define the Blueprints (The SSoTs)

1.  **Define Logic (Regex)**: In `common/src/grammar/regex.ts`, add your new, named, exported regular expression. Document its capture groups.
2.  **Define Structure (Grammar)**: In `syntaxes/org.tmLanguage.template.yaml`, add a rule that uses your `{{regex_name}}` and maps its capture groups to the scopes you designed.
3.  **Define Tests (Fixture)**: In `test/fixtures/`, create a new file (e.g., `F11-planning-line.org`). Add `* Test Case:` headlines for all scenarios. Use the format defined in *Section 4.4*.

*** Step 2: Test-Driven Development (L1 - Unit Test)

This loop validates your regex logic against your test fixtures.

1.  Run `pnpm test:unit`.
2.  The test runner will parse your fixture file, apply the regex specified in `:REGEX:`, and compare the results against the `#+RESULTS: regex` table.
3.  Adjust your regex in `regex.ts` until all tests pass.

*** Step 3: Build the Final Artifacts

1.  Run `pnpm build:grammar`: Generates the final `syntaxes/org.tmLanguage.json`.
2.  Run `pnpm build:inspections`: Generates human-readable inspection files in `test/inspections/`.

*** Step 4: End-to-End Validation (L2 & L3)

1.  **Manual Scope Verification (L2)**: Open the generated `.inspection.org` file. Use `Developer: Inspect Editor Tokens and Scopes` and verify that the highlighted scopes match the `:SCOPE_...:` properties in your fixture.
2.  **Snapshot Testing (L3)**: Run `pnpm test:integration`. On the first run, it will fail and create a `.snap` file. Review this snapshot carefully. If it is correct, run `pnpm test:integration -u` to accept it.

*** Step 5: Commit Your Work

Commit all the "source" files you have changed. Do *not* commit generated files.

- **DO commit**: `common/src/**/*.ts`, `syntaxes/org.tmLanguage.template.yaml`, `test/fixtures/*.org`, `test/integration/__snapshots__/*.snap`
- **DO NOT commit**: `syntaxes/org.tmLanguage.json`, `test/inspections/*.org`

** 4. Core Concepts & Conventions

This section defines the official conventions for our testing framework and project structure.

*** 4.1. File Naming Conventions

To ensure consistency and predictability across the project, all files MUST adhere to the following naming conventions:

- **Source Code (`.ts`)**: Use `kebab-case`.
  - Example: `headline-parser.ts`
- **Test Files (`.test.ts`)**: Use the name of the source file, suffixed with `.test`.
  - Example: `headline-parser.test.ts`
- **Documentation (`.org`)**:
  - **ADRs**: Use the format `[NNN]-short-title-in-kebab-case.org`.
    - Example: `001-choice-of-documentation-format.org`
  - **Feature Specs**: Use the format `[NNN]-feature-name-in-kebab-case.org`.
    - Example: `001-headline-folding.org`
  - **General Docs**: Use `kebab-case`.
    - Example: `project-overview.org`, `development-workflow.org`
- **Configuration Files**: Adhere to established community standards.
  - Example: `package.json`, `tsconfig.json`, `esbuild.js`

*** 4.2. Syntax Unit (`<syntax>`) Registry

A `<syntax>` is a conventional name for a distinct, testable unit of Org Mode grammar.

- *Principles*: Must have semantic cohesion, relate to a specific implementation in the grammar, and be testable at an appropriate granularity.
- *Registry*: (This list should be expanded as new syntaxes are added)
  - `headline`: Represents a headline, including stars, keyword, priority, and tags.
  - `list-item`: Represents any type of list item (unordered, ordered, checkbox).
  - `planning-line`: Represents a line containing `SCHEDULED:`, `DEADLINE:`, or `CLOSED:`.
  - `src-block`: Represents a `#+BEGIN_SRC` ... `#+END_SRC` block.

*** 4.3. Test Type (`<type>`) Registry

A `<type>` corresponds to a specific testing capability of our framework. Adding a new type requires modifying the test runner.

- *Principles*: Must correspond to a user-facing feature and have a unique, machine-parsable result structure.
- *Registry*: (This list will expand as the extension's capabilities grow)
  - `regex`: Tests regex capture groups. The result block is a table of `| Group # | Expected Value |`.
  - `folding`: (Future) Tests code folding ranges.
  - `symbols`: (Future) Tests the document symbol tree.

*** 4.4. Official Fixture Format

All test cases MUST follow this structure:

#+begin_src org
* Test Case: A descriptive name for the test
  :PROPERTIES:
  :SYNTAX:     syntax-name-1, syntax-name-2
  :SYNTAX_NAME_1_REGEX:      theRegexToTest
  :SYNTAX_NAME_1_SCOPE_1:    scope.for.group.1 (required)
  :SYNTAX_NAME_2_REGEX:      anotherRegex
  :END:

  #+BEGIN_SRC org
  The actual Org Mode text to test.
  #+END_SRC

  # This tests the 'regex' feature for the 'syntax-name-1' syntax
  #+RESULTS: regex syntax-name-1
  | Group # | Expected Value |
  |---------+----------------|
  | ...     | ...            |

  # This tests the 'regex' feature for the 'syntax-name-2' syntax
  #+RESULTS: regex syntax-name-2
  | Group # | Expected Value |
  |---------+----------------|
  | ...     | ...            |
#+end_src

** 5. Useful Commands

- `pnpm dev`: Watches source files and rebuilds them automatically.
- `pnpm lint`: Checks for code style issues.
- `pnpm check-types`: Checks for TypeScript type errors.
- `pnpm test`: Runs the full test suite (unit and integration).
* Development Workflow

This document describes the recommended workflow for developing new features for the Orgdown extension.

** Guiding Principles

- *Clarity over cleverness*: Code should be easy to understand.
- *Consistency*: Follow the established coding style and patterns.
- *Test everything*: Every new feature should be accompanied by tests.

** Steps for Adding a New Feature

1. *Create a Feature Document*:
  - Before writing any code, create a new Org Mode file in the ~docs/3_reference/feature_specs/~ directory (e.g., ~docs/3_reference/feature_specs/my-new-feature.org~).
   - In this document, describe the feature from a user's perspective, outline the technical approach, and define the acceptance criteria.
   - This ensures that we (and our AI collaborator) have a clear plan.

2. *Implement the Feature*:
   - Create a new branch for the feature.
   - Write the code, following the project's coding standards.
   - Add or update tests in the ~src/test/~ directory.

3. *Update Documentation*:
   - If the feature introduces a new command, keybinding, or architectural change, update the relevant documentation (~ARCHITECTURE.org~, etc.).

4. *Submit a Pull Request*:
   - Push the feature branch and open a pull request.
   - The pull request description should link to the feature document created in step 1.
